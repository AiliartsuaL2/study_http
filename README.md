Http - 김영한

인터넷 네트워크
인터넷 통신
    - A > B로 가면서 수많은 노드들을 거쳐 가는데, IP를 통해 감
    - 서버 클라이언트 통신시 클라이언트가 Request 시 서버가 Response 하는 형태
    - 인터넷 4계층 
        - 애플리케이션 계층 : HTTP,FTP
        - 전송 계층 : TCP, UDP
        - 인터넷 계층 : IP
        - 네트워크 인터페이스 계층
    IP
    - IP 주소를 통해서 감, Packet이라는 통신 단위로 전달됨
    - 패킷의 정보 : 출발지 IP 주소, 목적지 IP 주소 , 메세지
    - IP의 한계 : 
        - 비연결성 : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
        - 비신뢰성 : 중간에 패킷이 사라지거나(중간에 노드가 꺼져버리는 등) /  순서대로 오지않으면 문제가 됨
        - 프로그램 구분 : 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면,, 문제가 됨
TCP : IP에서 생기는 한계를 보완해주기 위해 만들어짐
    - HTTP의 정보를 소켓 라이브러리를 통해 전달
    - 그 위에 TCP 세그먼트를 씌움,
        - 출발지 Port, 목적지 Port, 전송 제어 정보, 순서 정보, 검증 정보 등
    -  그 위에 IP 패킷을 씌움
        - 출발지 IP 주소, 목적지 IP 주소 등
    - 특징 
        - 연결 지향(TCP 3way HandShake 가상 연결) : 아래 3가지 작업을 3way HandShake라고 함 ,, / 실제적으로 노드들이 연결이 된 게 아니라 논리적으로만 노드들이 연결 된 것
            - 클라이언트가 서버로 SYN (접속요청) 보냄
            - 서버가 SYN+ACK(요청 수락)를 보냄
            - 클라이언트가 ACK를 보냄 (요즘엔 최적화가 잘 되어서 여기서 데이터도 같이 보냄)
        - 데이터 전달 보증
            - 데이터 전송 이후 데이터 잘 받았다는 응답을 줌
        - 순서 보장
            - 패킷 순서 꼬일경우 잘못 된 곳부터 다시 보내라고 전달
        - 신뢰 할 수 있는 프로토콜
        - 현재 대부분 TCP 사용
UDP : 사용자 데이터그램 프로토콜
    - 기능이 거의 없음 (3way,전달보증,순서보장 이런거 없음) >> 커스터마이징 하기 좋음
    - 단순하고 빠른데 IP계층에 PORT랑 체크섬(검증)만 추가됨
    - TCP는 변경 할 수 없음(점유율이 90%가 넘어가기때문에)
    - 요즘 각광받고있음,, 웹 브라우저에서 http 통신시 TCP보다 최적화를 더 진행하기위해
PORT :  여러 애플리케이션 실행시 본인 IP로 여러 패킷이 오는데, 해당 패킷이 어느곳으로 온 패킷인지 할당해주는것
    - 같은 IP 내에서 프로세스를 구분해주는 것
    - IP 주소와 포트를 종합해서 TCP / IP 패킷이 라고 함
    - 0~65535 할당 가능
    - 0~1023 : 잘 알려진 포트로 사용하지 않는것이 좋음
        - FTP : 20,21
        - TELNET : 23
        - HTTP : 80
        - HTTPS : 443
DNS : 도메인 네임 시스템
    - 전화번호부 같은 서버
    - DNS 서버에서 받은 IP주소로 접근시켜주는 프로세스 


URI와 웹 브라우저 요청 흐름

URI : 자원(URI로 식별 할 수 있는 모든 것) 을 식별하는 통일된 방법 (하위의 큰 범주)
- URL : ResourceLocator ,, 리소스의 위치 (URI랑 거의 같음)
    - Scheme : 프로토콜 정의
    - port : 일반적으로 생략, 생략시 http:80, https:443
    - path : 리소스의 경로(계층적인 구조)
    - query(쿼리 파라미터, 쿼리 스트링, 문자형태임) : key=value 형태 ?로시작 &로 추가 가능,, >> ?keyA=ValueA&keyB=valueB
    - fragment : 서버로 전송되는 정보는 아니고 http 내부에서 사용
- URN : ResourceName ,, 리소스의 이름 ,, urn으로 자원을 찾을 수 있는 방법이 보편화 되어있지 않음


HTTP
- http의 모든것?
    - 거의 모든 형태의 데이터를 전부 http로 전송 할 수 있음
    - 심지어 서버간 데이터를 주고 받을 때도 대부분 http 사용
    - http/1.1 : 1997에 나옴, 가장 많이 사용, 가장 중요한 버전,, 2,3는 성능 개선에 초점이 맞춰져있음
        - 기반 프로토콜 
            - TCP: HTTP/1.1 , HTTP/2
            - UDP : HTTP/3
            - 현재 HTTP/1.1 주로 사용, 2,3도 점점 증가
    - 특징 
        - 클라이언트 서버 구조
            - 서버로 요청(Request) , 서버의 응답(Response) 구조, 클라는 서버에 요청을 보내고 응답을 대기함, 서버는 요청에 대한 결과를 만들어 응답함
            - 비즈니스 로직과 데이터를 서버에서 처리하고, UI는 클라이언트 단에서 처리함, (각각 독립적으로 진화 가능)
            - 
        - 무상태 프로토콜(Stateless) 지향
            - 서버가 클라이언트의 상태를 보존하지 않는다.
            - Stateful : 상태 유지,, 상태 유지시 중간에 대상이 바뀌면 context가 사라지기 때문에 장애가 생김 
            - StateLess : 정확한 정보를 그때그때 전달을 해주기때문에 확장성이 증가 (무상태는 트래픽 증가시 응답 서버를 쉽게 증설(스케일 아웃,, 수평 확장에 유리) 가능 그때 그때 같은 요청에 대한 처리를 할 수 있으니까)
                - 모든것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있다.
                    - 로그인 상태,, >> 일반적으로 브라우저의 쿠키와 세션등을 사용해서 상태 유지함
                    - 상태 유지는 최소한만 사용한다.
                - 데이터를 많이 보내야함
        - Http 메세지를 통해 통신
        - 단순함, 확장 가능
        - 비 연결성 
            - http는 기본적으로 연결을 유지하지 않는 모델
            - 연결을 유지하는 모델 : 다른 클라이언트와 연결해서 요청 응답을 하는동안 서버가 연결을 유지하기위해 서버의 자원이 계속 소모가 됨.
            - 연결을 유지하지 않는 모델 : 요청 응답 이후 연결을 종료시켜버리면 서버 입장에서 최소한의 자원만 유지한다.
단점
            - TCP/IP 연결(3wayHandAShake) 시간이 그때 그때 새로 추가가 된다.
            - 요청 할 때마다 매 번 웹 브라우저 사이트 요청시 수많은 자원이 따로따로 연결되며 함께 다운로드됨, 
            - HTTP 지속연결(Persistent Connections)으로 문제 해결함 (다운로드가 필요한 파일이 있을경우 지속 연결)
            - http2,3에서는 해당 문제에 대한 최적화를 했음
        - 최대한 스테이트 리스 설계를 하는게 중요함 (선착순 이벤트같은게 있어도 대응 할 수 있게) 
            - 첫 페이지는 로그인도 필요 없는 정적 페이지만 뿌리고
            - 그 안에서 놀게하다가 이벤트 참여버튼을 누르게하고 (시간 지연을 위해)
    - http 메세지
        - 구조 : start-line , header , empty line(CRLF, 무조건 있어야함), message body
            - start-line 
                - (요청의 start-line) request-line : 메서드 + SP(공백) + request-target(요청하는 경로)+SP(공백)+Http-version CRLF(엔터)
                    - 메서드 : GET,POST,PUT,DELETE
                    - request-target : 요청 대상, 절대경로[?쿼리]
                - (응답의 start-line) status-line : Http-version SP(공백) status-code SP(공백) reason-phrase CRLF(엔터)
                    - 상태 코드 
                        - 200 : 성공
                        - 400 : 클라 요청 오류
                        - 500 : 서버 내부 오류
                    - 이유 문구(reason-phrase) : 코드에 대한 사람이 이해 할 수 있는 짧은 문구
            - header-field : field-name”:”OWS field-value OWS  OWS:띄어쓰기를 허용한다는 뜻
                - header의 용도 : HTTP 전송에 필요한 모든 부가정보가 들어있음(표준 헤더가 엄청 많음),
                - Content-Type : 파일 타입명
                - charset : 캐릭터셋(인코딩 정보)
                - Content-Length : 길이 등등 
            - 메세지 바디(실 데이터, byte로 표현 할 수 있는 모든 데이터 전송 가능)

http 메서드 API (RestAPI)
- 리소스를 URI에 매핑한다 , URI 계층 구조를 활용한다.
- 행위는 리소스가 아니고, 자원이 리소스이다.
- 행위 구분은 메서드로 한다.
- 주요 메서드
    - GET : 리소스 조회
        - 서버에 전달하고싶은 데이터는 query를 통해서 전달, 
        - Body를 사용 가능하긴 한데, 지원하지 않는곳이 많음(GetMapping에 RequestBody를 잘 안씀)
    - POST : 요청 데이터 처리, 주로 등록에 사용
        - 메세지 바디를 통해 서버로 요청 데이터 전달 (서버에 처리를 부탁하는것)
        - 보통 신규 리소스 등록 하거나 프로세스 처리에 사용한다.
        - 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리 할 지 리소스마다 따로 정해야함,,(정해진 것이 없음)
        - 주문에서 결제 완료 > 배달 시작 버튼을 누를 때 라이더를 부르고 뭐 이런 프로세스들의 상태변경이 이뤄지는데, 이럴 때도 POST를 사용해야 함
        - 최대한 리소스로만 URI를 설계하되, 어쩔 수 없으면 start-delivery같이 리소스가 아닌것들을 URI에 사용도 함(컨트롤 URI)
        - JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우 조회이지만 POST를 써야함 (보통 조회시에는 Get이 유리)
    - PUT : 리소스를 완전히 대체, 해당 리소스가 없으면 생성 ,, 수정이 아니라 완전히 대체임!!
        - 리소스가 완전히 대체된다.(이전 리소스 날아감) >> 필드를 하나 빼고 보내면 다른 필드도 다 삭제됨 (개체 자체로 대체되는거임 필드가 아니라)
        - 파일을 복사하는거와 같음,
        - Post와의 큰 차이점 클라이언트가 리소스 위치를 알고, URI를 지정함 {id} @PathVariable 를 사용 
    - PATCH : 리소스 부분 변경(특정 필드)
        - 일부 필드만 변경시 사용
        - PATCH가 지원되지 않는 서버도 있는데 , 그런 경우에는 POST를 사용한다..
    - DELETE : 리소스 삭제
        - 리소스 제거,,,
- 기타 메서드
    - HEAD : GET과 동일하지만 상태줄과 헤더만 반환
    - OPTIONS , CONNECT , TRACE 있지만 거의 거의 거의 진짜 사용 안함

- 메서드의 속성
    - 안전 : 호출해도 해당 리소스의 변경이  이뤄지지않는것 (Get만)   // 지속 호출로 인해 로그가 쌓여 장애를 발생하는거는 생각하지않음
    - 멱등(Idempotent) : 한 번 호출하던, 두 번 호출하던 100번 호출하던 이전 상태와 이후 상태의 리소스 결과가 똑같아야함.
        - GET : 멱등
        - PUT : 멱등
        - DELETE : 멱등
        - POST : 멱등이 아니다, 두번 호출 시, 같은 결제가 중복해서 발생 할 수 있음 (id값 자동 생성하니까)
        - 활용 : 자동 복구 메커니즘,, 서버가 TIMEOUT등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 되는지에 대한 판단 근거..
            - 멱등 할 경우 같은 요청을 해도 되지만, 멱등하지 않은 경우 같은 요청을 하면 안되고 조회 이후 실행해야함,
        - 멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않는다. 트랜잭션의 버전이 바뀌는것등은 서버에서 체크를 해줘야함
    - 캐시 가능 : 응답 결과를 캐시에서 사용해도 되는지에대한 여부
        - GET,HEAD,POST,PATCH는 사용 가능 , 실제로는 GET,HEAD 정도만 캐시로 사용

- 메서드의 활용
    - 쿼리 파라미터를 통한 데이터 전송
        - GET
        - 정렬 필터(검색어)
    - 메세지 바디를 통한 데이터 전송
        - POST,PUT,PATCH
        - 회원 가입, 상품 주문, 리소스 등록, 리소스 변경 등

    - 정적 데이터 조회
        - 추가적인 파라미터 필요 없음
        - 조회는 GET 사용

    - 동적 데이터 조회
        - 쿼리 파라미터 사용
        - (조회 필터) 검색어, 게시판 목록 , 정렬조건 등,,
        - 조회는 GET 사용
    - html form 데이터 전송
        - GET, POST 만 지원함
        - Content-Type은 자동적으로 application/x-www.~~ (url encoding)으로 설정이 됨. 
        - POST 사용시 폼의 서밋 버튼을 누르면 http 메세지로 자동으로 생성을 해줌
        - Get의 경우, 폼의 서밋 버튼이 쿼리 파라미터로 넣어버린다,, 그래서 리소스 변경이 발생하는곳에서 GET사용하면 안됨(중요정보)
        - 폼에 enctype을 multipart/form-data로 바꾸면 Content-Type을 파일로 변경하게 해줌. 바이너리 데이터 전송시 사용
    - http api 데이터 전송
        - 폼을 쓰지 않는 모든 상황,, 직접 입력하면 됨(라이브러리가 해줌 어차피)
        - 앱 클라이언트와 전송시 많이 사용함
        - 웹에서는 AJAX로 많이 쓰임,
        - Content-Type : application/json을 주로 사용함, 예전에는 XML을 많이 사용했는데, 지금은 Json이 표준

    - http api 설계 예시
        - POST 기반 등록 (Collections) 대부분 POST 기반 사용함
            - 클라이언트는 등록될 리소스의 URI를 모름, 서버가 결정하기 때문
            - 서버가 새로 등록된 리소스 URI를 생성해준다. 이런 members를 컬렉션이라고 부름(서버가 관리하는 리소스 디렉토리,, URI를 생성 관리함 )
            - 회원 관리 시스템인 경우
                - 회원 목록 > /members   GET
                - 회원 등록 > /members   POST
                - 회원 조회 > /members/{id}   GET
                - 회원 수정 > /members/{id}   PATCH , PUT, POST
                    - 일부 수정할지(많이 사용), 완전히 덮어버릴지 (생각보다 거의 없음,, 게시판 정도,,) ,  둘다 애매하면 POST
                - 회원 삭제 > /members/{id}   DELETE
        - PUT 기반 등록 (Store)
            - 클라이언트가 리소스의 URI를 알고 있어야 한다.
            - 클라이언트가 관리하는 리소스 디렉토리,, 여기서 스토어는 /files
            - 파일 리스트 조회  > /files  GET
            - 파일 상세 조회 > /files/{filename} GET
            - 파일 등록 > /files/{filename} PUT
                - 없으면 새로 생성, 있으면 기존꺼 덮어버림..
            - 파일 삭제 > /files/{filename} DELETE
            - 파일 대량 등록 > /files POST
    - html form 사용
        - GET, POST만 지원하나 , AJAX 같은 기술을 사용해서 해결 가능,
        - 제약이 있기 때문에 URI에 동사로 된 경로를 사용, (컨트롤 URI)

http 상태코드 Status Code
    - 1xx : 요청이 수신되어 처리중 (거의 사용 안됨)
    - 2xx : 요청 정상 처리
        - 200 : OK // 요청에 대한 성공
        - 201 : Created // 요청에 성공하여 새로운 리소스가 생성됨, (POST)
            - Location에 URI 정보 넣어서 반환
        - 202 : Accepted // 요청이 접수되었으나 처리가 완료되지않음 (배치처리 등에서 사용,, 1시간 뒤 사용 같은)
        - 204 : No Content // 서버가 요청을 성공적으로 수행하였으나, 응답 페이로드에 보낼 데이터가 없음
            - 웹 문서 편집기에서 저장버튼을 누를경우,, 그대로 있는것처럼, 결과내용이 없어도 204 메세지 만으로 성공을 인식 할 수 있음
    - 3xx : 요청 완료하기 위해 클라이언트의 추가행동이 필요(Redirection) // 응답의 결과에 Location 헤더가 있으면 Location으로 자동 이동
        - 리다이렉션,, /event url 입력시, 바뀌었을경우 301 보내고 location에 /new-event를 넣어 보냄, ,, 그러면 클라이언트측에서 /new-event로 redirection 하여 다시 서버로 요청함, 200 OK 받으면 종료
            - 영구 리다이렉션 : 특정 리소스의 URI가 영구적으로 이동,
                - 실무에서는 301 씀
                - 301 : 리다이렉트 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음
                - 308 : 301과 기능은 같은데,  리다이렉트 요청시 요청 메서드와 본문이 유지됨 ,, 보통 URI 바뀌면 내부적으로 파라미터나 이런 것들이 다 바뀌기 때문에 보통 301 많이 쓰임
            - 일시 리다이렉션 : 일시적인 변경, ex ) 주문 완료 후 주문 내역 화면으로 이동,, 실무에서는 302,307 대부분 쓰임
                - 302 Found : 일시적으로 변경, 리다이렉트시 요청 메서드가 GET으로 변하고 본문이 제거 될 수 있음 (대부분 get으로 바꾸나 명확 x)
                - 307 Temporary Redirect : 302와 기능은 같으나, 리다이렉트시 요청 메서드와 본문 유지.(반드시)
                - 303 See Other : 302와 기능은 같으나 리다이렉트시 요청 메서드가 GET으로 변경 (반드시)
                - PRG(POST/Redirect/GET) : POST로 주문 후 웹 브라우저 새로고침시,, POST가 두번됨,(중복주문) >> POST 주문 후 주문 결과 화면을 GET 메서드로 리다이렉트 하는 것 ,, POST 주문시 응답 코드로200이 아니라 302를 주고 Location에 URI를 넣음(자동으로 GET으로 바뀌니까)
            - 특수 리다이렉션 : 결과 대신 캐시를 사용,,
                -   304 Not Modified : 캐시를 목적으로 사용 ,
                    - 클라이언트에게 리소스가 수정 되지 않았음을 알려줌 >> 캐시로 리다이렉트 처리함, 
                    - 응답에 메세지 바디를 포함하면 안됨,
                    - 조건부 HET,HEAD 요청시 사용
    - 4xx : 클라이언트 오류
        - 오류의 원인이 클라이언트에 있음 ,, 여러번 재 요청 해도 동일
        - 400 Bad Request : 클라이언트의 잘못된 요청으로 서버가 요청을 처리 할 수 없음 
            - 요청 구문, 메세지 등등 오류
            - 요청 내용을 다시 검토하고 보내야 함
            - 요청 구문등을 철저하게 검증해서 명확하게 400오류를 줘야함
        - 401 Unauthorized : 클라이언트가 해당 리소스에 대한 인증이 필요함
            - Authentication : 본인이 누구인지 확인(로그인)
            - Authorization : 권한 부여(로그인 이후 권한 레벨)
            - Unauthorized 이지만, 로그인이 안된 경우임,;; 이름 설정을 잘못했음
        - 403 Fobbiden
            - 서버가 요청을 이해했지만 승인을 거부함
            - 보통 퍼미션 관련, (Admin이 아닌 사용자 등,,)
        - 404 Not Found
            - 요청 리소스를 찾을 수 없음
            - 혹은 클라이언트가 권한이 부족한 리소스에 접근시, 해당 리소스를 숨기고 싶을 때
    - 5xx : 서버 오류,, 왠만하면 만들면 안되는 에러임.
        - 오류의 원인이 서버에 있음,, 여러번 재시도 했을때 성공 할 가능성이 있다.
        - 500 Internal Server Error
            - 서버 내부 문제로 오류 발생 , 애매하면 500
        - 503 Service Unavaliable
            - 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리 할 수 없음,,
            - Retry-After 헤더 필드로 얼마뒤에 복구될 지 말해줄 수 있음
- 알 지 못하는 코드 반환시, 100번대 단위로 해석해서 처리

HTTP Header
- Http 전송에 필요한 모든 부가 정보를 들어감
    - Representation(표현) = 표현 메타데이터 + 표현 데이터
        - 표현의 본문은 실제 페이로드, 표현의 헤더가 헤더,
        - 표현 헤더 : 전송, 응답 둘 다 사용
            - Content-Type : 표현 데이터의 형식
                - 미디어 타입, 문자 인코딩 ,, text/html; charset=utf-8 // application/json 
            - Content-Encoding : 표현 데이터의 압축 방식
                - 표현 데이터를 압축하기위해 사용
                - 데이터 전달하는쪽에서 압축 후 인코딩 헤더 추가
                - 읽는 쪽에서는 인코딩 헤더의 정보로 압축을 해제
            - Content-Language : 표현 데이터의 자연 언어
                - 한국어, 영어, 등등
            - Content-Length : 표현 데이터의 길이
                - 
    - message body(메세지 본문)를 통해 표현 데이터 전달
    - 메세지 본문 = 페이로드
    - 표현 헤더와 표현 헤더는 표현 데이터를 해석 할 수 있는 정보를 제공함. (데이터 유형, 데이터 길이, 압축 정보)

- 헤더_협상(콘텐츠 네고시에이션)
    - 클라이언트가 서버에게 조건을 달라는 대로 맞춰달라고 요청! 하는것, 서버는 이를 이행 하지 못할수도 있음(해당 요구조건을 제공 하지 않는경우에는,,)
    - Accept-Language : 클라이언트가 한국어 브라우저를 쓰는데, 다중언어를 지원하는 서버면 요청값이 없으면 디폴트값으로 주고, 헤더 Accpet-Language에 언어 설정하면 언어를 맞춰서 줌.
        - 디폴트 독일어에 영어 지원이면 Accept-Language에 한국어 설정시 독어가 오기때문에, 차순위를 받기 위해 우선순위를 부여해서 설정
            - Quality Values(q)값을 사용한다. (0~1 우선순위, 클수록 높음) 생략시 1,
            - Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7 
    -   협상 우선순위2 : 조건이 더 구체적인것을 우선한다.
        - Accept: text/*,text/plain,text/plain;format=flowed,*/* 인 경우
            - 1. text/plain;format=flowed
            - 2. text/plain
            - 3. text/*
            - 4. */*
            - 순으로 조건의 우선순위가 정해진다.
    - 협상 우선순위3 : 구체적인 것을 기준으로 미디어 타입을 맞춘다.
        - 위와같은경우 text/html이면 3번에 해당하는 QualityValue값을 갖는다.
    - Accept-Charset: 클라이언트가 선호하는 문자 인코딩
    - Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
    - Accept-Language: 클라이언트가 선호하는 자연 언어
- 협상 헤더는 요청시에만 사용한다.

- 헤더_전송 방식
    - 단순 전송 : 버전,응답코드, 이유문구, Content-Type, Content-Length 정도만 필요함
    - 압축 전송 : 데이터를 압축하고 Content-Encoding 속성이 추가로 필요함(압축을 어떤 방식으로 했는지 필요하기 때문)
    - 분할 전송 : 분할해서 전송하고 Transfer-Encoding 옵션이 필요함, 마지막은 0을 보냄
        - Content-Length를 넣으면 안됨
    - 범위 전송 : 클라가 범위를 요청해서 보냈을경우 응답에 Content-Range를 추가해서 보내야 함

- 헤더_일반 정보
    - From : 유저 에이전트의 이메일 정보
        - 일반적으로 잘 사용되지 않음, 검색 엔진같은곳에서 주로 사용
    - Referer : 이전 웹 페이지의 주소
        - 현재 요청된 이전 웹 페이지의 주소
        - Referer을 유입 경로 분석 가능
        - 요청에서 사용한다.
    - User-Agent : 클라이언트 애플리케이션 정보(브라우저의 버전 등.. Mozila, Safari 등)
        - 통계정보
        - 요청에서 사용
    - Server : 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보
        - 응답에서 사용
    - Date : 메세지가 발생한 날짜와 시간
        - 응답에서만 사용

- 헤더_특별한 정보 제공 헤더
    - Host : 요청한 호스트 정보(도메인 주소값 www.aaa.com//)
        - 요청에서 사용, 필수값
        - 하나의 서버에서 여러 도메인 처리시 구분하기위해 필요
    - Location : 페이지 리다이렉션 용 주소
        - 3xx응답 결과에 Location 헤더가 있으면 Location위치로 자동 이동
        - 201의 Location은 리소스가 생성된 곳의 URI 주소
    - Allow : URI 경로가 있는데, 지원되지않는 메소드를 사용했을경우 405 에러에 포함시킴 (잘 사용 안함)
    - Retry-After : 503뜰 경우, 서비스가 언제까지 불능인지 알려주는 응답 헤더, 잘 사용 못함(언제 복구될지 모르니까;)
- 헤더_인증 :
    -  Authorization : 클라이언트 인증 정보를 서버에 전달
    - WWW-Authenticate : 리소스 접근 했는데 permittion 문제가 있는경우 401 Unauthorized 응답이랑 함께 사용한다.
- 헤더_쿠키 :  Http는 무상태 프로토콜(데이터 요청 응답 이후에는 연결이 끊어지는), 따라서 서버는 기억을 못하기 때문에 이를 기억하게 하기 위해서 헤더에 쿠키를 사용
    - 사용처
        - 사용자 로그인 세션 관리
            - 서버는 로그인 했을 때, 세션 키를 만들어서 쿠키에 넣어서 클라이언트에 반환해줌
        - 광고 정보 트래킹
    - 쿠키 정보는 항상 서버에 전송됨,,
        - 네트워크 트래픽이 추가로 유발되니 최소한의 정보만 사용,(세션 id, 인증 토큰 등)
        - 서버에 전송하지 않고 , 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지를 참고해서 사용함.
    - 보안에 민감한 데이터는 저장하면 안된다
    - expires : 만료일 지정
    - max-age : 초 기준을 지정하고 음수가되면 삭제시킴
        - 종류
            - 세션 쿠키 : 만료 날짜를 생략하면 브라우저 종료시까지만 유지
            - 영속 쿠키 : 만료 날짜를 입력하면 해당 날짜까지 유지

    - Set-Cookie : 서버에서 클라이언트로 쿠키 전달
    - Cookie : 클라이언트가 서버에서 받은 쿠키를 저장하고 , Http 요청시 서버로 전달한다.
    - 웹브라우저에 쿠키가 있는경우 해당 도메인 접속시 쿠키를 무조건 서버쪽으로 같이 보내준다. 서버에서는 그걸 확인해서 정보를 확인함.
    - domain : 모든 도메인에 보내면 안되니까,  명시한 문서 기준 도메인, 서브 도메인 포함
    - path : 해당 경로를 포함한 하위 모든 경로 페이지만 쿠키를 접근할 수 있음, 일반적으로 루트로 경로 지정
    - 보안 
        - Secure : 원래 http,https 구분을 안하는데, Secure적용시 https에만 전송
        - HttpOnly : XSS 공격 방지로, 자바 스크립트에서 접근 불가
        - SameSite : XSRF 공격 방지로, 요청하는 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키 전송
- 헤더_캐시
    - 캐시가 없으면 데이터가 변경되지 않아도 네트워크를 통해 데이터를 다운받아야함
    - 네트워크는 이용료가 비쌈,, 따라서 네트워크 리소스 사용을 최소화 시켜야함
    - cache-control : max-age = 60 이런식으로 캐시의 유효기간을 설정해두고,(데이터가 변경될 수 있기 때문에) 
    - (검증 헤더) Last-Modified : 2022년 12월 11일 몇시~ 이렇게 잡아두고, 
    - 캐시 시간이 초과되지않았을경우 캐시 서버(로컬)에서 불러오고, 
    - 캐시 시간이 초과해서 서버에 다시 요청(if-modified-since 헤더에 응답받은 Last-Modified 값 전송)하면 아래 두가지 상황이 됨/ 검증 헤더와 조건부 요청 
        - 기존 데이터가 변경되었거나 
            - 다시 다운로드를 받아야함
        - 기존 데이터가 변경되지 않았거나
            - 날짜 변경값이 같으면 데이터가 수정이 되지 않았음을 확인, 
            - 304 Not Modified를 보내면서(본인 캐시 저장소로 Redirect 하라는 뜻) 헤더에는 동일하게 cache-control과 Last-Modified를 넣고, Http Body를 빼고 보냄 : 데이터의 양이 줄어듬 

    - 검증헤더 : 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
        - Last-Modified : 최종 수정 시각
        - ETag (EntityTag): 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠.
            - 데이터가 변경되면 이 이름을 바꾸어 변경함(Hash를 다시 생성, 해시는 컨텐츠가 같으면 완전 똑같음) 
            - 캐시 제어 로직을 서버에서 완전하게 관리(클라이언트 입장에서는 블랙박스,,)
    - 조건부 요청 헤더 : 검증 헤더로 조건에 따른 분기
        - If-Modified-Since : 이후 데이터가 수정 되었는지 
        - If-None-Match : ETag와 매칭이 되면 수정이 안됨을 확인, 수정이 안되었으면 (ETag랑 비교)304 Not Found
    - Cache-Control(캐시 제어 헤더)
        - Cache-Control : 캐시 지시어
            - max-age : 캐시 유효시간, 초 단위
            - no-cache(프록시 캐시) : 데이터는 캐시를 해도 되지만, 항상 Origin(원) 서버에서 검증하고 사용
            - no-store : 데이터에 민감한 정보가 있으므로 저장하면 안됨, 메모리에서 사용하고 최대한 빨리 삭제 
        - Expires : 캐시 만료일을 정확한 날짜로 지정
            - 지금은 더 유용한 max-age를 권장하고, 같이쓰면 max-age가 우선순위잡힘
        - private : 응답이 해당 사용자만을 위한 것 (로컬 캐시서버)
        - public : 응답이 public 캐시에 저장되어도 됨 (프록시 캐시서버)

    - 프록시 캐시 : 원서버와 거리가 물리적으로 멀으니까,(오래걸림) 국가적으로 요청이 있으면 원서버에 직접 접근이 아닌 프록시 캐시 서버에 접근하게 만드는 것,,
        - public 캐시

    - 캐시 무효화 : 캐시가 되면 안되는 페이지(통장 잔고 등)가 있는경우 원서버와 갱신을 시켜줘야함
        - no-cache : 원서버 검증
            - 프록시와 원서버에 조건 분기하는 순간에 장애가 나있는 경우 프록시에서 검증시킴,, 따라서 must-revalidate 사용
        - no-store : 데이터 민감정보니 저장 x
        - must-revalidate : 캐시 만료 후 최초 조회시, 원 서버에서 검증,
            - 프록시 서버와 원서버의 네트워크 단절되있었는경우 504를 뿌려줌
        - Pragma: no-cache : HTTP 1.0 하위 호환
        - 위 옵션 4가지를 다 넣어줘야 함
